#!/usr/bin/env python3
# Generates docs/tools_index.md by scanning known tools folders and
# detects duplicate filenames across tool roots.

from pathlib import Path

ROOT = Path(__file__).resolve().parents[3]  # c:/dev/AIOS (from ai/tools/system/)
DOCS = ROOT / "docs"
OUT = DOCS / "tools_index.md"

TOOL_DIRS = [
    ("ai_intelligence", ROOT / "ai" / "tools"),
    ("runtime", ROOT / "runtime" / "tools"),
    ("core", ROOT / "core" / "tools"),
    ("interface", ROOT / "interface" / "tools"),
]

HEADER = (
    "# AIOS Tools Index\n\n"
    "Note: This file is generated by ai/tools/system/index_tools.py.\n"
    "Run the VS Code task \"Generate Tools Index\" to refresh.\n\n"
    "- AI Intelligence tools (primary): ai/tools\n"
    "- Runtime Intelligence tools (legacy): runtime/tools\n"
    "- Module tools (locality): core/tools, interface/tools\n\n"
)


def collect_tools():
    entries = []
    name_to_paths = {}
    for scope, folder in TOOL_DIRS:
        if not folder.exists():
            continue
        files = []
        for p in sorted(folder.rglob("*")):
            if p.is_file():
                rel = p.relative_to(ROOT)
                rel_posix = str(rel).replace("\\", "/")
                files.append(rel_posix)
                name_to_paths.setdefault(p.name, set()).add(rel_posix)
        entries.append((scope, folder, files))
    return entries, name_to_paths


def render(entries, dup_map):
    lines = [HEADER]
    for scope, folder, files in entries:
        lines.append(f"## {scope} tools\n")
        lines.append(f"Path: `{folder.relative_to(ROOT).as_posix()}`\n")
        if not files:
            lines.append("(no files found)\n\n")
            continue
        for f in files:
            lines.append(f"- {f}")
        lines.append("")
    # Duplicates
    dups = {k: v for k, v in dup_map.items() if len(v) > 1}
    lines.append("## duplicates\n")
    if not dups:
        lines.append("None found.\n")
    else:
        for name, paths in sorted(dups.items()):
            lines.append(f"- {name}")
            for p in sorted(paths):
                lines.append(f"  - {p}")
        lines.append("")
    return "\n".join(lines) + "\n"


def main():
    entries, name_to_paths = collect_tools()
    OUT.parent.mkdir(parents=True, exist_ok=True)
    OUT.write_text(render(entries, name_to_paths), encoding="utf-8")
    print(f"Wrote {OUT}")


if __name__ == "__main__":
    main()
