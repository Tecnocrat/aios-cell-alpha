import argparse
import asyncio
import json
import os
import time
from typing import List, Dict, Any

try:
    from subprocess_manager import (
        AsyncSubprocessManager,
        FractalTTLCache,
    )  # type: ignore
except ImportError:
    from .subprocess_manager import (
        AsyncSubprocessManager,
        FractalTTLCache,
    )  # type: ignore

DEFAULT_CHECKS = [
    ["git", "rev-parse", "--abbrev-ref", "HEAD"],
    ["git", "status", "--porcelain"],
    ["python", "--version"],
    ["pip", "--version"],
]


def summary_from_results(results: List[Dict[str, Any]]) -> Dict[str, Any]:
    return {
        "timestamp": int(time.time()),
        "checks": [
            {
                "cmd": r["cmd"],
                "ok": r["returncode"] == 0,
                "duration_ms": r["duration_ms"],
                "sample": (r.get("stdout") or r.get("stderr") or "")[:200],
            }
            for r in results
        ],
        "ok": all(r["returncode"] == 0 for r in results),
    }


async def do_continue(cache_ttl: int = 300) -> Dict[str, Any]:
    mgr = AsyncSubprocessManager(
        cache=FractalTTLCache(memory_ttl=30, disk_ttl=cache_ttl)
    )
    results = await mgr.run_parallel(
        DEFAULT_CHECKS,
        timeout=15.0,
        cache_ttl=cache_ttl,
    )
    return summary_from_results(results)


def ensure_log_dir() -> str:
    log_dir = os.path.join(os.path.dirname(__file__), "..", "logs", "agent")
    log_dir = os.path.abspath(log_dir)
    os.makedirs(log_dir, exist_ok=True)
    return log_dir


def write_summary(payload: Dict[str, Any]) -> str:
    log_dir = ensure_log_dir()
    ts = time.strftime(
        "%Y%m%d_%H%M%S", time.localtime(payload.get("timestamp", time.time()))
    )
    path = os.path.join(log_dir, f"continue_{ts}.json")
    with open(path, "w", encoding="utf-8") as f:
        json.dump(payload, f, ensure_ascii=False, indent=2)
    return path


def main() -> None:
    parser = argparse.ArgumentParser(description="AIOS AINLP Agentic Runner")
    parser.add_argument(
        "command",
        choices=["continue", "status"],
        help="Agent command",
    )
    parser.add_argument(
        "--cache-ttl",
        type=int,
        default=300,
        help="Cache TTL seconds for checks",
    )
    args = parser.parse_args()

    if args.command == "continue":
        payload = asyncio.run(do_continue(cache_ttl=args.cache_ttl))
        path = write_summary(payload)
        print(json.dumps({"summary": payload, "log_path": path}, indent=2))
    elif args.command == "status":
        log_dir = ensure_log_dir()
        files = sorted(
            [f for f in os.listdir(log_dir) if f.startswith("continue_")],
            reverse=True,
        )
        if not files:
            print(json.dumps({"status": "no_runs"}, indent=2))
            return
        with open(os.path.join(log_dir, files[0]), "r", encoding="utf-8") as f:
            print(f.read())


if __name__ == "__main__":
    main()
