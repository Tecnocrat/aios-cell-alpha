#!/usr/bin/env python3
"""AIOS Evolution Scheduler (UP5)

Purpose:
    * Run mutation/evaluation cycles (fitness lineage).
    * Persist each cycle as JSONL + lightweight metric crystal.
    * Periodically emit a weekly improvement crystal summarizing trajectory.

Design:
    * Pluggable mutator & fitness functions.
    * JSONL lineage in runtime_intelligence/logs/evolution/.
    * Weekly roll-up or --force-weekly flag triggers summary crystal.

Captured per cycle: candidate_id, parent_id, generation, fitness_score,
mutation_type, timestamp_utc, optional notes.
"""
from __future__ import annotations

import json
import time
import uuid
import random
from dataclasses import dataclass, asdict
from pathlib import Path
from datetime import datetime, timezone, timedelta
from typing import Callable, Dict, List, Optional, Any

try:
    from context_crystallization_engine import create_metric_crystal  # type: ignore
except Exception:  # pragma: no cover
    create_metric_crystal = None  # type: ignore

ROOT = Path(__file__).resolve().parent.parent.parent
EVOL_LOG_DIR = ROOT / "runtime_intelligence" / "logs" / "evolution"
EVOL_LOG_DIR.mkdir(parents=True, exist_ok=True)
LINEAGE_FILE = EVOL_LOG_DIR / "evolution_lineage.jsonl"
WEEKLY_SUMMARY_FILE = EVOL_LOG_DIR / "weekly_summary.json"

@dataclass
class CandidateRecord:
    candidate_id: str
    parent_id: Optional[str]
    generation: int
    fitness_score: float
    mutation_type: str
    timestamp_utc: str
    notes: Optional[str] = None

    def to_jsonl(self) -> str:
        return json.dumps(asdict(self), separators=(",", ":"))

# Default mutation & fitness (placeholders)
def default_mutator(parent: Optional[CandidateRecord]) -> Dict[str, Any]:
    return {
        "mutation_type": random.choice(
            ["param_tweak", "structure", "refactor"]
        ),
        "notes": "auto-generated placeholder mutation",
    }

def default_fitness(candidate_payload: Dict[str, Any]) -> float:
    base = 0.5 if candidate_payload["mutation_type"] == "param_tweak" else 0.4
    jitter = random.random() * 0.2
    return round(base + jitter, 4)

class EvolutionScheduler:
    def __init__(
        self,
        mutator: Callable[[Optional[CandidateRecord]], Dict[str, Any]] = default_mutator,
        fitness_fn: Callable[[Dict[str, Any]], float] = default_fitness,
        lineage_file: Path = LINEAGE_FILE,
    ) -> None:
        self.mutator = mutator
        self.fitness_fn = fitness_fn
        self.lineage_file = lineage_file
        self.records: List[CandidateRecord] = []
        if lineage_file.exists():
            for ln in lineage_file.read_text().splitlines():
                try:
                    data = json.loads(ln)
                    self.records.append(CandidateRecord(**data))
                except Exception:
                    continue

    def latest_generation(self) -> int:
        return max((r.generation for r in self.records), default=-1)

    def best_record(self) -> Optional[CandidateRecord]:
        if not self.records:
            return None
        return max(self.records, key=lambda r: r.fitness_score)

    def run_cycle(
        self, parent: Optional[CandidateRecord] = None
    ) -> CandidateRecord:
        gen = self.latest_generation() + 1
        payload = self.mutator(parent)
        fitness = self.fitness_fn(payload)
        rec = CandidateRecord(
            candidate_id=str(uuid.uuid4()),
            parent_id=parent.candidate_id if parent else None,
            generation=gen,
            fitness_score=fitness,
            mutation_type=payload.get("mutation_type", "unknown"),
            timestamp_utc=datetime.now(timezone.utc).isoformat(),
            notes=payload.get("notes"),
        )
        with self.lineage_file.open("a", encoding="utf-8") as f:
            f.write(rec.to_jsonl() + "\n")
        self.records.append(rec)
        # Per-cycle crystal (lightweight)
        if create_metric_crystal:
            try:
                create_metric_crystal(
                    metric_snapshot={
                        "generation": rec.generation,
                        "fitness_score": rec.fitness_score,
                        "mutation_type": rec.mutation_type,
                        "candidate_id": rec.candidate_id,
                    },
                    capsule_ids=["evolution-orchestration-up5"],
                    kpi_dimensions=["fitness_score"],
                    source_tag=f"evolution_cycle_{rec.generation}",
                )
            except Exception:
                pass
        return rec

    def weekly_summary_needed(self) -> bool:
        if not WEEKLY_SUMMARY_FILE.exists():
            return True
        try:
            data = json.loads(WEEKLY_SUMMARY_FILE.read_text())
            last = datetime.fromisoformat(data.get("period_end"))
            return datetime.now(timezone.utc) - last >= timedelta(days=7)
        except Exception:
            return True

    def emit_weekly_summary(
        self, force: bool = False
    ) -> Optional[Dict[str, Any]]:
        if not force and not self.weekly_summary_needed():
            return None
        if not self.records:
            return None
        best = self.best_record()
        avg_fit = round(
            sum(r.fitness_score for r in self.records) / len(self.records), 4
        )
        summary = {
            "period_end": datetime.now(timezone.utc).isoformat(),
            "total_generations": self.latest_generation() + 1,
            "best_fitness": best.fitness_score if best else None,
            "best_candidate_id": best.candidate_id if best else None,
            "average_fitness": avg_fit,
            "lineage_records": len(self.records),
        }
        WEEKLY_SUMMARY_FILE.write_text(json.dumps(summary, indent=2))
        # Weekly improvement crystal
        if create_metric_crystal:
            try:
                create_metric_crystal(
                    metric_snapshot=summary,
                    capsule_ids=["evolution-orchestration-up5"],
                    kpi_dimensions=["best_fitness", "average_fitness"],
                    source_tag="evolution_weekly_summary",
                )
            except Exception:
                pass
        return summary


def main() -> None:
    import argparse
    parser = argparse.ArgumentParser(
        description="AIOS Evolution Scheduler (UP5)"
    )
    parser.add_argument(
        "--cycles",
        type=int,
        default=5,
        help="Number of mutation/evaluation cycles to run",
    )
    parser.add_argument(
        "--force-weekly",
        action="store_true",
        help="Force weekly summary emission",
    )
    args = parser.parse_args()
    sched = EvolutionScheduler()
    parent: Optional[CandidateRecord] = sched.best_record()
    for _ in range(args.cycles):
        parent = sched.run_cycle(parent)
        # Simple exploitation strategy: keep best as parent half the time
        if random.random() < 0.5:
            parent = sched.best_record()
        time.sleep(0.05)  # light spacing
    summary = sched.emit_weekly_summary(force=args.force_weekly)
    print(json.dumps({
        "cycles_run": args.cycles,
        "latest_generation": sched.latest_generation(),
        "best_fitness": sched.best_record().fitness_score if sched.best_record() else None,
        "weekly_summary_emitted": bool(summary)
    }, indent=2))

if __name__ == "__main__":
    main()
