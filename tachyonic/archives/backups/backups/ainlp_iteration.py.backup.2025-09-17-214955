#!/usr/bin/env python3
"""
AIOS AINLP Iteration Entry Point

Contract:
- Input: optional --id (string), --mode {dry-run,commit}
- Reads: docs/module_index.json (if present), docs/tools_index.md (if present)
- Output:
  - Always writes runtime_intelligence/logs/iteration_<timestamp>.log
  - If commit: writes docs/summary/iteration_<id or timestamp>.md
    (lightweight receipt)
Success criteria:
- Runs on a clean checkout without extra setup (Python 3.x only)
- No destructive writes; commit mode writes a new file, not overwrite
"""

from __future__ import annotations
import argparse
import datetime as dt
from pathlib import Path
import json
from typing import Optional, Tuple, Dict, Any

ROOT = Path(__file__).resolve().parents[2]
DOCS = ROOT / "docs"
LOGS = ROOT / "runtime_intelligence" / "logs"
AGENT_LOG_DIR = LOGS / "agent"

MODULE_INDEX = DOCS / "module_index.json"
TOOLS_INDEX = DOCS / "tools_index.md"
SUMMARY_DIR = DOCS / "summary"


def now_stamp() -> str:
    return dt.datetime.now(dt.timezone.utc).strftime("%Y%m%d_%H%M%S")


def load_json(path: Path):
    if path.exists():
        try:
            return json.loads(path.read_text(encoding="utf-8"))
        except Exception as e:
            return {"error": f"Failed to parse {path.name}: {e}"}
    return None


def read_text_if_exists(path: Path):
    if path.exists():
        try:
            return path.read_text(encoding="utf-8")
        except Exception as e:
            return f"<error reading {path}: {e}>"
    return None


def latest_agent_summary() -> Tuple[Optional[Path], Optional[Dict[str, Any]]]:
    """Locate and parse the latest agent CONTINUE summary JSON."""
    if not AGENT_LOG_DIR.exists():
        return None, None
    files = sorted(
        [
            p
            for p in AGENT_LOG_DIR.iterdir()
            if (
                p.is_file()
                and p.name.startswith("continue_")
                and p.suffix == ".json"
            )
        ],
        reverse=True,
    )
    if not files:
        return None, None
    latest = files[0]
    try:
        data = json.loads(latest.read_text(encoding="utf-8"))
        return latest, data
    except Exception:
        return latest, None


def write_log(lines: list[str]) -> Path:
    LOGS.mkdir(parents=True, exist_ok=True)
    p = LOGS / f"iteration_{now_stamp()}.log"
    p.write_text("\n".join(lines) + "\n", encoding="utf-8")
    return p


def write_summary(identifier: str, content: str) -> Path:
    SUMMARY_DIR.mkdir(parents=True, exist_ok=True)
    p = SUMMARY_DIR / f"iteration_{identifier}.md"
    p.write_text(content, encoding="utf-8")
    return p


def main():
    ap = argparse.ArgumentParser(
        description="AIOS AINLP Iteration Entry Point"
    )
    ap.add_argument(
        "--id", dest="id", default=None, help="Iteration identifier"
    )
    ap.add_argument(
        "--mode",
        dest="mode",
        default="dry-run",
        choices=["dry-run", "commit"],
        help="Run mode",
    )
    args = ap.parse_args()

    iter_id = args.id or now_stamp()

    module_index = load_json(MODULE_INDEX)
    # tools_index currently unused; kept for future enrichment
    _ = read_text_if_exists(TOOLS_INDEX)
    agent_path, agent_summary = latest_agent_summary()

    lines = [
        "AINLP Iteration Receipt",
        f"id: {iter_id}",
        f"mode: {args.mode}",
        f"time_utc: {dt.datetime.now(dt.timezone.utc).isoformat()}",
        f"module_index_present: {MODULE_INDEX.exists()}",
        f"tools_index_present: {TOOLS_INDEX.exists()}",
        (
            "module_count: "
            + (
                str(len(module_index))
                if isinstance(module_index, dict)
                else "n/a"
            )
        ),
    ]

    if isinstance(module_index, dict) and "modules" in module_index:
        lines.append(f"modules_listed: {len(module_index['modules'])}")

    if agent_summary and isinstance(agent_summary, dict):
        ok = agent_summary.get("summary", {}).get("ok")
        checks = agent_summary.get("summary", {}).get("checks", [])
        lines.append(
            f"agent_summary_present: True (ok={ok}, checks={len(checks)})"
        )
    else:
        lines.append("agent_summary_present: False")

    log_path = write_log(lines)

    if args.mode == "commit":
        summary = [
            f"# AINLP Iteration {iter_id}",
            "",
            "This is a lightweight iteration receipt generated by the entry",
            "point.",
            "",
            "## inputs",
            (
                "- module_index: "
                + ("present" if MODULE_INDEX.exists() else "missing")
            ),
            (
                "- tools_index: "
                + ("present" if TOOLS_INDEX.exists() else "missing")
            ),
            (
                "- agent_summary: "
                + (
                    f"present ({agent_path.relative_to(ROOT).as_posix()})"
                    if agent_path
                    else "missing"
                )
            ),
            "",
            "## notes",
            "- Extend this document with concrete steps, deltas, decisions.",
            "",
            "## agent checks (latest)",
            "",
            (
                "- overall: "
                + (
                    "ok" if (agent_summary or {}).get("summary", {}).get("ok")
                    else "not-ok or missing"
                )
            ),
            "- checks:",
        ]

        # Render up to first 5 checks briefly
        if agent_summary and isinstance(agent_summary, dict):
            checks = agent_summary.get("summary", {}).get("checks", [])
            for chk in checks[:5]:
                cmd = " ".join(chk.get("cmd", [])[:4])
                ok_s = "ok" if chk.get("ok") else "fail"
                dur = chk.get("duration_ms")
                sample = (chk.get("sample") or "").replace("\n", " ")[:120]
                summary.append(f"  - {ok_s} [{dur} ms] {cmd} :: {sample}")
        else:
            summary.append("  - none")

        summary += [
            "## provenance",
            f"- log: {log_path.relative_to(ROOT).as_posix()}",
        ]
        summary_path = write_summary(iter_id, "\n".join(summary) + "\n")
        print(f"Wrote summary: {summary_path}")

    print(f"Wrote log: {log_path}")


if __name__ == "__main__":
    main()
