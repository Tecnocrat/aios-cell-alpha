#!/usr/bin/env python3
"""Automated generation of current-status-* capsules
(UP1 Governance Automation).

Emits a new status capsule into AIOS_PROJECT_CONTEXT.md when a material change
in structural or readiness metrics is detected (or when forced).

Material change heuristics (v1):
  - Crystal count delta
  - Validation success flip (success -> fail or fail -> success)
  - KPI fail count changed OR any new KPI failures
  - Viewer executable presence change
  - New day without existing capsule for that day (date rollover)

Usage:
    python scripts/generate_status_capsule.py          # only if change
    python scripts/generate_status_capsule.py --force  # always emit
        python scripts/generate_status_capsule.py --force-new  \
                # force even if id exists

The capsule format mirrors the manually ingested
current-status-2025-08-16 block and appends at EOF. Lineage is derived
from the previous status capsule plus any runtime / vision capsules
already referenced there.
"""
from __future__ import annotations

import argparse
import json
import re
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Any, cast

ROOT = Path(__file__).resolve().parent.parent
PROJECT_CONTEXT = ROOT / "AIOS_PROJECT_CONTEXT.md"
RI_CONTEXT = ROOT / "runtime_intelligence" / "context"
SUMMARY_FILE = RI_CONTEXT / "full_system_validation.json"
CRYSTAL_DB = RI_CONTEXT / "knowledge_crystals.db"
CORE_BUILD = ROOT / "core" / "build"
IS_WIN = __import__("sys").platform.startswith("win")
VIEWER_NAME = (
    "aios_tachyonic_viewer.exe" if IS_WIN else "aios_tachyonic_viewer"
)

STATUS_HEADER_RE = re.compile(
    r"^## Capsule: current-status-(\d{4}-\d{2}-\d{2}.*)$", re.MULTILINE
)


def _load_validation_summary() -> Dict[str, Any]:
    if not SUMMARY_FILE.exists():
        return {}
    try:
        return json.loads(SUMMARY_FILE.read_text())
    except Exception:  # pragma: no cover
        return {}


def _viewer_exists() -> bool:
    # Common paths produced by CMake single or multi-config
    for cand in [
        CORE_BUILD / "bin" / VIEWER_NAME,
        CORE_BUILD / "bin" / "Debug" / VIEWER_NAME,
    ]:
        if cand.exists():
            return True
    return False


def _crystal_count() -> Optional[int]:
    if not CRYSTAL_DB.exists():
        return None
    try:
        import sqlite3

        conn = sqlite3.connect(CRYSTAL_DB)
        cur = conn.cursor()
        cur.execute("SELECT COUNT(*) FROM knowledge_crystals")
        n = cur.fetchone()[0]
        conn.close()
        return int(n)
    except Exception:  # pragma: no cover
        return None


def _parse_previous_status_blocks(text: str) -> List[Dict[str, str]]:
    blocks: List[Dict[str, str]] = []
    for match in STATUS_HEADER_RE.finditer(text):
        start = match.start()
        # Find end (next '## Capsule:' or EOF)
        next_index = text.find("## Capsule:", start + 5)
        if next_index == -1:
            block = text[start:]
        else:
            block = text[start:next_index]
        blocks.append(
            {"id_line": match.group(0), "id": match.group(1), "block": block}
        )
    return blocks


def _derive_lineage(
    prev_block: Optional[Dict[str, str]], new_status_id: str
) -> str:
    if not prev_block:
        # Fallback baseline lineage
        return "[chatgpt-integration-2025-06-29]"
    # Look for existing lineage line inside block
    # non-greedy capture inside []
    m = re.search(r"Lineage:\s*\[(.*?)\]", prev_block["block"])  # noqa: E501
    if not m:
        return f"[{prev_block['id']}]"  # at least chain previous
    lineage_items = [s.strip() for s in m.group(1).split(",") if s.strip()]
    # Ensure previous status capsule id present for chain continuity
    if prev_block["id"] not in lineage_items:
        lineage_items.append(prev_block["id"])
    # Remove duplicates preserving order
    seen = set()
    ordered: List[str] = []
    for item in lineage_items:
        if item not in seen:
            ordered.append(item)
            seen.add(item)
    return f"[{', '.join(ordered)}]"


def _summarize_change(
    prev_metrics: Dict[str, Any], cur_metrics: Dict[str, Any]
) -> str:
    changes: List[str] = []
    for k in sorted(cur_metrics.keys()):
        if prev_metrics.get(k) != cur_metrics.get(k):
            changes.append(k)
    if not changes:
        return "No material metric deltas; periodic snapshot."  # forced case
    return "Changed: " + ", ".join(changes)


def _extract_prev_metrics(
    prev_block: Optional[Dict[str, str]]
) -> Dict[str, Any]:
    if not prev_block:
        return {}
    # Parse lines starting with '|' in table for key/value pairs.
    metrics: Dict[str, Any] = {}
    for line in prev_block["block"].splitlines():
        if line.startswith("| ") and " | " in line:
            # Skip header separators
            if set(line.strip()) <= {"|", "-", " "}:
                continue
            parts = [p.strip() for p in line.strip().strip("|").split("|")]
            if len(parts) >= 2:
                key = parts[0]
                val = parts[1]
                metrics[key] = val
    # Additional parse: viewer_present, crystal_total etc if previously output
    return metrics


def main() -> None:
    ap = argparse.ArgumentParser()
    ap.add_argument(
        "--force",
        action="store_true",
        help="Force generation if today's capsule does not yet exist.",
    )
    ap.add_argument(
        "--force-new",
        action="store_true",
        help="Force generation even if capsule id exists (adds suffix).",
    )
    args = ap.parse_args()

    if not PROJECT_CONTEXT.exists():
        print("[status-auto] Project context file missing; abort.")
        return

    text = PROJECT_CONTEXT.read_text(encoding="utf-8")
    blocks = _parse_previous_status_blocks(text)
    prev_block = blocks[-1] if blocks else None
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    base_id = f"current-status-{today}"
    existing_ids = {b["id"] for b in blocks}
    status_id = base_id
    if base_id in existing_ids and args.force_new:
        # append letter suffix until unique
        suffix_ord = ord('a')
        while status_id in existing_ids:
            status_id = f"{base_id}-{chr(suffix_ord)}"
            suffix_ord += 1
    elif base_id in existing_ids and not (args.force or args.force_new):
        # Already have today's capsule; treat as no-op
        print(
            f"[status-auto] Capsule {base_id} exists; "
            "skip (use --force-new)."
        )
        return

    summary = _load_validation_summary()
    success = summary.get("success")
    raw_eval = summary.get("kpi_evaluation", {})
    if isinstance(raw_eval, dict):
        kpi_eval = cast(Dict[str, Dict[str, Any]], raw_eval)
    else:
        kpi_eval = {}
    kpi_statuses: List[str] = []
    for v in kpi_eval.values():
        if isinstance(v, dict) and "status" in v:
            val = v.get("status")
            if isinstance(val, str):
                kpi_statuses.append(val)
    fail_count = kpi_statuses.count("fail")
    pass_count = kpi_statuses.count("pass")
    unmeasured = kpi_statuses.count("unmeasured")
    viewer_present = _viewer_exists()
    crystal_total = _crystal_count()

    cur_struct_metrics = {
        "Viewer Present": str(viewer_present),
        "Crystal Count": (
            str(crystal_total) if crystal_total is not None else "None"
        ),
        "Validation Success": str(success),
        "KPI Pass": str(pass_count),
        "KPI Fail": str(fail_count),
        "KPI Unmeasured": str(unmeasured),
    }
    prev_metrics = _extract_prev_metrics(prev_block)

    # Change detection
    material = False
    if not prev_block:
        material = True
    else:
        # Date rollover OR any watched metric changed.
        watched_keys = [
            "Viewer Present",
            "Crystal Count",
            "Validation Success",
            "KPI Fail",
        ]
        for k in watched_keys:
            if prev_metrics.get(k) != cur_struct_metrics.get(k):
                material = True
                break
    if not material and not (args.force or args.force_new):
        print("[status-auto] No material change; skipping capsule emission.")
        return

    lineage = _derive_lineage(prev_block, status_id)
    # Remove accidental bare date tokens (e.g., "2025-08-16") if inserted
    lineage = re.sub(r",?\s*\d{4}-\d{2}-\d{2}(?=[^\d])", "", lineage)
    lineage = re.sub(r",,", ",", lineage).replace("[,", "[").replace(", ]", "]")
    change_summary = _summarize_change(prev_metrics, cur_struct_metrics)

    ingestion_iso = datetime.now(timezone.utc).isoformat()
    health_rows = ["| Aspect | Value |", "| ------ | ----- |"]
    for k, v in cur_struct_metrics.items():
        health_rows.append(f"| {k} | {v} |")

    recommendations: List[str] = []
    if fail_count > 0:
        recommendations.append(
            "Investigate failing KPIs; refine thresholds or instrumentation."
        )
    if unmeasured > 0:
        recommendations.append("Instrument remaining unmeasured KPIs (UP2).")
    if viewer_present is False:
        recommendations.append(
            "Ensure viewer target builds successfully for surface generation."
        )
    if not recommendations:
        recommendations.append("Proceed to UP2 KPI instrumentation expansion.")

    capsule_md_parts = [
        "",
        f"## Capsule: {status_id}",
        "### Title: Automated Status Snapshot (Governance Automation v1)",
        (
            "### Source Artifact: validation automation "
            "(generate_status_capsule.py)"
        ),
        f"### Ingestion Date (UTC): {ingestion_iso}",
        "### Summary",
        (
            "Automated snapshot produced after validation harness run. "
            f"{change_summary}"
        ),
        "",
        "### Structural & KPI Metrics",
        *health_rows,
        "",
        "### Governance & Context Alignment",
        "- Generated by UP1 automation (no manual root edits).",
        "- Enables lineage diffing of structural readiness over time.",
        "- Feeds future trend crystals (UP10) once batching enabled.",
        "",
        "### Derived Recommendations",
    ]
    capsule_md = "\n".join(capsule_md_parts) + "\n"
    for i, rec in enumerate(recommendations, 1):
        capsule_md += f"{i}. {rec}\n"
    capsule_md += f"\n---\nCapsule ID: {status_id}\nLineage: {lineage}\n---\n"

    PROJECT_CONTEXT.write_text(
        text.rstrip() + "\n" + capsule_md + "\n", encoding="utf-8"
    )
    print(f"[status-auto] Emitted capsule {status_id}")


if __name__ == "__main__":  # pragma: no cover
    main()
