name: file-criticality
on:
  pull_request: {}
  push:
    branches: [OS]

jobs:
  criticality:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch full history for git diff operations
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      - name: Install minimal deps
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
      - name: Generate file scores
        shell: pwsh
        run: |
          python runtime_intelligence/tools/generate_file_scores.py
      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: file-criticality
          path: |
            governance/file_criticality_index.jsonl
            runtime_intelligence/logs/file_scores/latest.json
          if-no-files-found: error
      - name: PR File Criticality Comment
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            function topChanged(changed, indexMap){
              const paths = changed.filter(c=>c.Status!=='D').map(c=>c.Path);
              const scored = indexMap.filter(r=>paths.includes(r.path));
              return scored.sort((a,b)=>b.criticality_score-a.criticality_score).slice(0,10);
            }
            function loadIndex(){
              if(!fs.existsSync('governance/file_criticality_index.jsonl')) return [];
              return fs.readFileSync('governance/file_criticality_index.jsonl','utf8')
                .split(/\r?\n/).filter(Boolean).map(l=>{ try { return JSON.parse(l) } catch { return null } }).filter(Boolean);
            }
            async function loadChanged(){
              // Use GitHub API instead of git diff since fetch-depth:1 limits history
              const files = await github.rest.pulls.listFiles({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                per_page: 100
              });
              return files.data.map(f => ({Status: f.status.toUpperCase()[0], Path: f.filename}));
            }
            function regenerateIndexForCommit(commit){
              const cp = require('child_process');
              // Stash current working tree state inside temp dir (checkout is detached in action)
              cp.execSync(`git checkout --quiet ${commit}`);
              try { cp.execSync('python runtime_intelligence/tools/generate_file_scores.py',{stdio:'ignore'}); } catch {}
              const idx = loadIndex();
              // Return to PR head
              return idx;
            }
            function buildMap(list){
              const m = new Map();
              list.forEach(o=>m.set(o.path,o));
              return m;
            }
            const indexMap = loadIndex();
            const changed = await loadChanged();
            // Base index regeneration for delta (best effort)
            const evt = JSON.parse(fs.readFileSync(process.env.GITHUB_EVENT_PATH,'utf8'));
            const baseSha = evt.pull_request.base.sha;
            const headSha = evt.pull_request.head.sha;
            const cp = require('child_process');
            let baseIndex = [];
            try {
              // Skip base index regeneration if commits not available (shallow clone)
              if (cp.execSync('git cat-file -t ' + baseSha, {encoding:'utf8'}).trim() === 'commit') {
                baseIndex = regenerateIndexForCommit(baseSha);
              }
            } catch (e) {
              // ignore - base index not available
            } finally {
              // Restore head
              try { cp.execSync(`git checkout --quiet ${headSha}`); } catch {}
              try { cp.execSync('python runtime_intelligence/tools/generate_file_scores.py',{stdio:'ignore'}); } catch {}
            }
            const baseMap = buildMap(baseIndex);
            const top = topChanged(changed, indexMap);
            const tableRows = top.map(r=>`| ${r.path} | ${r.criticality_score} | ${r.tier} |`).join('\n');
            const header = '| Path | Score | Tier |';
            const sep = '|------|-------|------|';
            // Delta metrics
            const changedScores = [];
            changed.forEach(c=>{
              if(c.Status==='D') return; // Already prevented by hook for core/high
              const cur = indexMap.find(x=>x.path===c.Path);
              if(!cur) return;
              const prev = baseMap.get(c.Path);
              if(prev){
                const delta = cur.criticality_score - prev.criticality_score;
                changedScores.push({path:c.Path, prev:prev.criticality_score, cur:cur.criticality_score, delta});
              } else {
                changedScores.push({path:c.Path, prev:null, cur:cur.criticality_score, delta:null});
              }
            });
            const deltas = changedScores.filter(d=>d.delta!==null);
            const avgDelta = deltas.length ? (deltas.reduce((a,b)=>a+b.delta,0)/deltas.length).toFixed(2) : '0.00';
            const pos = deltas.filter(d=>d.delta>0).length;
            const neg = deltas.filter(d=>d.delta<0).length;
            const unchanged = deltas.filter(d=>d.delta===0).length;
            const deltaTableRows = changedScores.slice(0,15).map(d=>`| ${d.path} | ${d.prev??'-'} | ${d.cur} | ${d.delta===null?'(new)':d.delta.toFixed(2)} |`).join('\n');
            const deltaHeader = '| Path | Prev | Cur | Δ |';
            const deltaSep = '|------|------|-----|----|';
            const body = `###  File Criticality Impact\nChanged high-impact files (top up to 10):\n${header}\n${sep}\n${tableRows || '(none)'}\n\n**Δ Score Summary** (vs base): avg=${avgDelta} (pos=${pos} neg=${neg} zero=${unchanged})\n${deltaHeader}\n${deltaSep}\n${deltaTableRows || '(no scored changes)'}\n\n_Total files scored: ${indexMap.length}. Core/High deletions require staged deprecation._`;
            const {owner, repo} = context.repo; const issue_number = context.issue.number;
            const marker = '###  File Criticality Impact';
            const comments = await github.rest.issues.listComments({owner, repo, issue_number, per_page: 100});
            const existing = comments.data.find(c => c.body && c.body.startsWith(marker));
            if (existing) {
              await github.rest.issues.updateComment({owner, repo, comment_id: existing.id, body});
            } else {
              await github.rest.issues.createComment({owner, repo, issue_number, body});
            }
